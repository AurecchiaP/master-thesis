\documentclass[mscthesis,12pt]{usiinfthesis}
\usepackage{lipsum}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{algcompatible}
\usepackage[noend]{algpseudocode}
\usepackage{listings}
\usepackage{caption}
\usepackage{subcaption}

\lstdefinelanguage{algebra}
{morekeywords={import,sort,constructors,observers,transformers,axioms,if,
else,end},
sensitive=false,
morecomment=[l]{//s},
}



\title{Repartition Optimization for \\ Distributed B+ Trees} %compulsory
\specialization{Distributed Systems}%optional
% \subtitle{Subtitle: Reinventing the World} %optional 
\author{Paolo Aurecchia} %compulsory
\begin{committee}
\advisor{Prof.}{Fernando}{Pedone} %compulsory
\coadvisor{Dr.}{Paulo}{Coelho}{} %optional
\end{committee}
\Day{Yesterday} %compulsory
\Month{June} %compulsory
\Year{2019} %compulsory, put only the year
\place{Lugano} %compulsory

% \dedication{To my beloved} %optional
% \openepigraph{Someone said \dots}{Someone} %optional

%\makeindex %optional, also comment out \theindex at the end

\begin{document}

\maketitle %generates the titlepage, this is FIXED

\frontmatter %generates the frontmatter, this is FIXED

\include{src/abstract}

% \begin{acknowledgements}
% Thank people
% \end{acknowledgements}

\tableofcontents 
% \listoffigures %optional
% \listoftables %optional

\mainmatter

\include{src/introduction}
\include{src/background}
\include{src/geopaxos-with-b+tree}
\include{src/conclusion}



% \chapter{Introduction}

% \lipsum



% \chapter[Short title]{A chapter title which will run over two lines --- it's for
%   testing purpose}

% \lipsum[1-2]

% \section{The first section}
% \lipsum[3-4]

%  \section{The second, math section}

% \textbf{Theorem 1 (Residue Theorem).}
% Let $f$ be analytic in the region $G$ except for the isolated singularities $a_1,a_2,\ldots,a_m$. If $\gamma$ is a closed rectifiable curve in $G$ which does not pass through any of the points $a_k$ and if $\gamma\approx 0$ in $G$ then
% \[
% \frac{1}{2\pi i}\int_\gamma f = \sum_{k=1}^m n(\gamma;a_k) \text{Res}(f;a_k).
% \]
% \textbf{Theorem 2 (Maximum Modulus).}
% \emph{Let $G$ be a bounded open set in $\mathbb{C}$ and suppose that $f$ is a continuous function on $G^-$ which is analytic in $G$. Then}
% \[
% \max\{|f(z)|:z\in G^-\}=\max \{|f(z)|:z\in \partial G \}.
% \]

% \section[third]{A very very long section, titled ``The third section'', with
%   a rather  short text alternative (third)}
% \lipsum \texttt{Some Test}
% \lstset{language=algebra,linewidth=0.95\linewidth,breaklines=true,numbers=left,
% basicstyle=\ttfamily,numberstyle=\tiny,escapeinside={//*}{\^^M},
% mathescape=true}
% \begin{lstlisting}
% import IntSpec, ItemSpec;

% sort cart; //*\label{sort}

% constructors //*\label{begin-sig}
% create() $\longrightarrow$ cart;
% insert(cart, item) $\longrightarrow$ cart;
% observers
% amount(cart) $\longrightarrow$ int;
% transformers
% delete(cart, item) $\longrightarrow$ cart; //*\label{end-sig}

% axioms //*\label{begin-axioms}
% forall c: cart, i, j: item 

% amount(create()) $=$ 0; //*\label{begin-amount}
% amount(insert(c,i)) $=$ amount(c) $+$ price(i); //*\label{end-amount}
% delete(create(),i) $=$ create(); //*\label{begin-delete}
% delete(insert(c,i),j) $=$
% if (i =$\:$= j) c
% else insert(delete(c,j),i); //*\label{end-axioms}
% end
% \end{lstlisting}

% As you can easily see from the above listing \citet{bbggs:iet07}
% define something weird based on the BPEL specification
% \citep{bpelspec}.
% \nocite{*}

\appendix %optional, use only if you have an appendix
\chapter{Algorithms Pseudo-Code}
\section{}
This appendix contains the pseudo-code for the main algorithms implemented to perform the repartition of the B+ Trees. In particular, the codes are All0-Combinations \ref{alg:all-combinations}, Fixed-Size \ref{alg:fixed-size}, Variable-Size \ref{alg:variable-size}, Hot-Groups \ref{alg:hot-groups} and LRU caching \ref{alg:lru}.

\begin{algorithm}
	\caption{All-Combinations}\label{alg:all-combinations}
	\begin{algorithmic}[1]
	\Function{repartition}{}:
	\State $repartition\_tree(root)$
	\EndFunction
	\Function{repartition\_tree}{$node$}:
	  \If {$node.has\_changed$}
		% \State $vw = vector(node.statistics)$
		\State $topology = new\ topology(node.workloads)$
		\State $g = topology.calculate\_min\_cost\_graph()$
		\For {$vertex \in g$}:
		  \If {$vertex.has\_object$}:
		  \State $node.partitions += vertex$
			\If {$vertex == my\_partition\ \wedge vertex.has\_object$}
			  \State $node.preferred\_partition = vertex$
			\EndIf
		  \EndIf
		\EndFor
	  \EndIf
	  \If{$!node\ is\ leafnode$}:
		\For {$child\ \in\ node.child\_nodes$}:
		  \State $repartiton\_tree(child)$
		  \EndFor
	  \EndIf
	  \EndFunction
	  \Function{calculate\_min\_cost\_graph}{}:
	  \State $min\_cost = \infty$
		\ForAll {$graph\ combination$}:
		  \State $cost = calculate\_cost(graph, vertices)$
		  \If {$cost < min\_cost$}:
			\State $min\_cost = cost$
			\State $min\_graph = graph$
		  \EndIf
		\EndFor
	  \State \textbf{return} $min\_graph$
	  \EndFunction
	  \Function{calculate\_cost}{$vertex$}:
		\State $in\_reads, out\_reads, in\_writes, out\_writes = 0$
		\State $reps = |vertex \in graph.vertices \mid vertex.has\_object|$
		\For {$vertex \in graph.vertices$}:
		\State $min\_weight = nearest vertex \in graph | vertex.has\_object$
		\State $max\_weight = furthest\ vertex \in graph | vertex.has\_object$
		  \If {$vertex.has\_object$}:
			\State $in\_reads+= 1$
			\If {$rep\_size > 1$}:
			\State $\in\_writes+= vertex.writes$
			\Else
			\State  $\in\_writes+= 1 $
			\EndIf
		  \Else:
			\State $out\_reads += vertex.reads \cdot min\_weight$
			\State $out\_writes += vertex.writes \cdot min\_weight$
		  \EndIf
		\EndFor
		\State $cost = in\_reads+ out\_reads + (in\_writes+ out\_writes) \cdot max\_weight$
		\State \textbf{return} $cost$
	\EndFunction
	\end{algorithmic}
	\end{algorithm}

\begin{algorithm}
	\caption{Fixed-Size Buckets}\label{alg:fixed-size}
	\begin{algorithmic}[1]
	  \Function{repartition}{}:
	\State $repartition\_tree(root, true)$
	\EndFunction
	\Function{repartition\_tree}{$node, is\_root$}:
	\State $is\_bucket\_root = node.level\ is\ odd \vee is\_root$
	  \If {$node.has\_changed \vee is\_bucket\_root$}:
		% \State $vw = vector(node.statistics)$
		\State $topology = new\ topology(node.workloads)$
		\State $g = topology.calculate\_min\_cost\_graph()$
		\For {$vertex \in g$}:
		  \If {$vertex.has\_object$}:
		  \State $node.partitions += vertex$
			\If {$vertex == my\_partition\ \wedge vertex.has\_object$}
			  \State $node.preferred\_partition = vertex$
			\EndIf
		  \EndIf
		\EndFor
	  \EndIf
	  \If{$!node\ is\ leafnode$}:
		\For {$child\ \in\ node.child\_nodes$}:
		\If {$is\_bucket\_root = node.level\ is\ odd$}:
		  \State $child.partitions = node.partitions$
		  \State $child.preferred\_partition = node.preferred\_partition$
		\EndIf
		  \State $repartiton\_tree(child, false)$
		  \EndFor
	  \EndIf
	  \EndFunction
	  \Function{calculate\_min\_cost\_graph}{}:
	  \State $min\_cost = \infty$
		\ForAll {$graph\ combination$}:
		  \State $cost = calculate\_cost(graph, vertices)$
		  \If {$cost < min\_cost$}:
			\State $min\_cost = cost$
			\State $min\_graph = graph$
		  \EndIf
		\EndFor
	  \State \textbf{return} $min\_graph$
	  \EndFunction
	  \Function{calculate\_cost}{$vertex$}:
	  \State $in\_reads, out\_reads, in\_writes, out\_writes = 0$
	  \State $reps = |vertex \in graph.vertices \mid vertex.has\_object|$
	  \For {$vertex \in graph.vertices$}:
	  \State $min\_weight = nearest\ vertex \in graph | vertex.has\_object$
	  \State $max\_weight = furthest\ vertex \in graph | vertex.has\_object$
	  \If {$vertex.has\_object$}:
	  \State $in\_reads+= 1$
	  \If {$rep\_size > 1$}:
	  \State $\in\_writes+= vertex.writes$
	  \Else
	  \State  $\in\_writes+= 1 $
	  \EndIf
	  \algstore{fixed-size}
	\end{algorithmic}
\end{algorithm}
\begin{algorithm}
	\begin{algorithmic}[1]
		\algrestore{fixed-size}
		  \Else:
			\State $out\_reads += vertex.reads \cdot min\_weight$
			\State $out\_writes += vertex.writes \cdot min\_weight$
		  \EndIf
		\EndFor
		\State $cost = in\_reads+ out\_reads + (in\_writes+ out\_writes) \cdot max\_weight$
		\State \textbf{return} $cost$
	\EndFunction
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
	\caption{Variable-Size Buckets}\label{alg:variable-size}
	\begin{algorithmic}[1]
	  \Function{repartition}{}:
	\State $repartition\_tree(parent\_node, workload\_ratio)$
	\EndFunction
	\Function{repartition\_tree}{$node, is\_root$}:
	  \State $my\_workload = 0$
	  \If {$node.has\_changed$}:
		\State $my\_workload = sum(node.workloads)$
		\If {$my\_workload < workload\_ratio * treshold$}:
		\State $child.partitions = parent.partitions$
		\State $child.preferred\_partition = parent.preferred\_partition$
		\Else
		\State $topology = new\ topology(node.workloads)$
		\State $g = topology.calculate\_min\_cost\_graph()$
		\For {$vertex \in g$}:
		  \If {$vertex.has\_object$}:
		  \State $node.partitions += vertex$
			\If {$vertex == my\_partition\ \wedge vertex.has\_object$}
			  \State $node.preferred\_partition = vertex$
			\EndIf
		  \EndIf
		\EndFor
	  \EndIf
	  \EndIf
	  \If{$!node\ is\ leafnode$}:
		\For {$child\ \in\ node.child\_nodes$}:
		  \State $repartiton\_tree(child, false)$
		  \EndFor
	  \EndIf
	  \EndFunction
	  \Function{calculate\_min\_cost\_graph}{}:
	  \State $min\_cost = \infty$
		\ForAll {$graph\ combination$}:
		  \State $cost = calculate\_cost(graph, vertices)$
		  \If {$cost < min\_cost$}:
			\State $min\_cost = cost$
			\State $min\_graph = graph$
		  \EndIf
		\EndFor
	  \State \textbf{return} $min\_graph$
	  \EndFunction
	  \algstore{variable-size}
	\end{algorithmic}
\end{algorithm}
\begin{algorithm}
	\begin{algorithmic}[1]
		\algrestore{variable-size}
	  \Function{calculate\_cost}{$vertex$}:
		\State $in\_reads, out\_reads, in\_writes, out\_writes = 0$
		\State $reps = |vertex \in graph.vertices \mid vertex.has\_object|$
		\For {$vertex \in graph.vertices$}:
		\State $min\_weight = nearest\ vertex \in graph | vertex.has\_object$
		\State $max\_weight = furthest\ vertex \in graph | vertex.has\_object$
		  \If {$vertex.has\_object$}:
			\State $in\_reads+= 1$
			\If {$rep\_size > 1$}:
			\State $\in\_writes+= vertex.writes$
			\Else
			\State  $\in\_writes+= 1 $
			\EndIf
		  \Else:
			\State $out\_reads += vertex.reads \cdot min\_weight$
			\State $out\_writes += vertex.writes \cdot min\_weight$
		  \EndIf
		\EndFor
		\State $cost = in\_reads+ out\_reads + (in\_writes+ out\_writes) \cdot max\_weight$
		\State \textbf{return} $cost$
	\EndFunction
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
	\caption{Hot Groups}\label{alg:hot-groups}
	\begin{algorithmic}[1]
	\Function{repartition}{}:
	\State $repartition\_tree(root)$
	\EndFunction
	\Function{repartition\_tree}{$node$}:
	  \If {$node.has\_changed$}
		% \State $vw = vector(node.statistics)$
		\State $topology = new\ topology(node.workloads)$
		\State $g = topology.calculate\_min\_cost\_graph()$
		\For {$vertex \in g$}:
		  \If {$vertex.has\_object$}:
		  \State $node.partitions += vertex$
			\If {$vertex == my\_partition\ \wedge vertex.has\_object$}
			  \State $node.preferred\_partition = vertex$
			\EndIf
		  \EndIf
		\EndFor
	  \EndIf
	  \If{$!node\ is\ leafnode$}:
		\For {$child\ \in\ node.child\_nodes$}:
		  \State $repartiton\_tree(child)$
		  \EndFor
	  \EndIf
	  \EndFunction
	  \algstore{hot-groups}
	\end{algorithmic}
\end{algorithm}
\begin{algorithm}
	\begin{algorithmic}[1]
		\algrestore{hot-groups}
	  \Function{calculate\_min\_cost\_graph}{}:
	  \State $min\_cost = \infty$
	  \State $max\_rw = 0$
	  \For {$vertex \in graph$}:
		\If {$vertex.read + vertex.write > max\_rw$}:
		  \State $max\_rw = vertex.read + vertex.write$
		\EndIf
	  \EndFor
	  \ForAll {$graph\ combination$}:
		\For {$vertex \in combination$}:
		  \If {$(vertex.reads + vertex.writes) / max\_rw < threshold:$}
			\State $skip\ combination$
		  \EndIf
		\EndFor
		\State $cost = calculate\_cost(graph, vertices)$
		\If {$cost < min\_cost$}:
		  \State $min\_cost = cost$
		  \State $min\_graph = graph$
		\EndIf
	  \EndFor
	  \State \textbf{return} $min\_graph$
	  \EndFunction
	  \Function{calculate\_cost}{$vertex$}:
		\State $in\_reads, out\_reads, in\_writes, out\_writes = 0$
		\State $reps = |vertex \in graph.vertices \mid vertex.has\_object|$
		\For {$vertex \in graph.vertices$}:
		\State $min\_weight = nearest vertex \in graph | vertex.has\_object$
		\State $max\_weight = furthest\ vertex \in graph | vertex.has\_object$
		  \If {$vertex.has\_object$}:
			\State $in\_reads+= 1$
			\If {$rep\_size > 1$}:
			\State $\in\_writes+= vertex.writes$
			\Else
			\State  $\in\_writes+= 1 $
			\EndIf
		  \Else:
			\State $out\_reads += vertex.reads \cdot min\_weight$
			\State $out\_writes += vertex.writes \cdot min\_weight$
		  \EndIf
		\EndFor
		\State $cost = in\_reads+ out\_reads + (in\_writes+ out\_writes) \cdot max\_weight$
		\State \textbf{return} $cost$
	\EndFunction
	\end{algorithmic}
	\end{algorithm}
  
	\begin{algorithm}
		\caption{LRU cache}\label{alg:lru}
		\begin{algorithmic}[1]
		  \Function{repartition}{}:
		\State $repartition\_tree(root)$
		\EndFunction
		\Function{repartition\_tree}{$node$}:
		  \If {$node.has\_changed$}
			% \State $vw = vector(node.statistics)$
			\State $topology = new\ topology(node.workloads)$
			\State $g = topology.calculate\_min\_cost\_graph()$
			\For {$vertex \in g$}:
			  \If {$vertex.has\_object$}:
			  \State $node.partitions += vertex$
				\If {$vertex == my\_partition\ \wedge vertex.has\_object$}
				  \State $node.preferred\_partition = vertex$
				\EndIf
			  \EndIf
			\EndFor
		  \EndIf
		  \If{$!node\ is\ leafnode$}:
			\For {$child\ \in\ node.child\_nodes$}:
			  \State $repartiton\_tree(child)$
			  \EndFor
		  \EndIf
		  \EndFunction
		  \Function{calculate\_min\_cost\_graph}{}:
		  \State $min\_cost = \infty$
		  \State $lru\_key = keygen(node.statistics)$
		  \State $value = lru.get(key)$
		  \If {$value$}:
			\State \textbf{return} $value$
		  \EndIf
			\ForAll {$graph\ combination$}:
			  \State $cost = calculate\_cost(graph, vertices)$
			  \If {$cost < min\_cost$}:
				\State $min\_cost = cost$
				\State $min\_graph = graph$
			  \EndIf
			\EndFor
		  \State $lru.put(key, min\_graph)$
		  \State \textbf{return} $min\_graph$
		  \EndFunction

		  \algstore{lru}
		\end{algorithmic}
	\end{algorithm}
	\begin{algorithm}
		\begin{algorithmic}[1]
			\algrestore{lru}
		  \Function{calculate\_cost}{$vertex$}:
			\State $in\_reads, out\_reads, in\_writes, out\_writes = 0$
			\State $reps = |vertex \in graph.vertices \mid vertex.has\_object|$
			\For {$vertex \in graph.vertices$}:
			\State $min\_weight = nearest vertex \in graph | vertex.has\_object$
			\State $max\_weight = furthest\ vertex \in graph | vertex.has\_object$
			  \If {$vertex.has\_object$}:
				\State $in\_reads+= 1$
				\If {$rep\_size > 1$}:
				\State $\in\_writes+= vertex.writes$
				\Else
				\State  $\in\_writes+= 1 $
				\EndIf
			  \Else:
				\State $out\_reads += vertex.reads \cdot min\_weight$
				\State $out\_writes += vertex.writes \cdot min\_weight$
			  \EndIf
			\EndFor
			\State $cost = in\_reads+ out\_reads + (in\_writes+ out\_writes) \cdot max\_weight$
			\State \textbf{return} $cost$
		\EndFunction
		\end{algorithmic}
		\end{algorithm}
	  
	  

\backmatter

% \chapter{Glossary} %optional

%\bibliographystyle{alpha}
%\bibliographystyle{dcu}
\bibliographystyle{plainnat}
\bibliography{biblio}

%\cleardoublepage
%\theindex %optional, use only if you have an index, must use
	  %\makeindex in the preamble
% \lipsum

\end{document}
